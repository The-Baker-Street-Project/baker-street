# Phase 1.5: Installer & UX Fixes Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix 4 high-priority issues: installer feature secret prompting (BAK-21), auto-enable feature flags (BAK-22), UI conversation persistence (BAK-23), and sysadmin console auth + feature tools (BAK-26).

**Architecture:** Four independent tasks across three services (installer/Rust, UI/React, sysadmin/TypeScript). Each can be implemented and tested independently with no cross-dependencies.

**Tech Stack:** Rust (ratatui TUI installer), React/TypeScript (UI), Node.js/TypeScript (sysadmin), Kubernetes API

---

### Task 1: BAK-21 — Fix Installer Feature Secret Prompting

**Files:**
- Modify: `tools/installer/src/main.rs:382-409` (handle_features_key Enter handler)
- Modify: `tools/installer/src/main.rs:318-359` (submit_current_secret)
- Test: manual TUI test (Rust TUI is hard to unit test for interactive flow)

**Context:** When the user enables a feature (e.g., Perplexity) in the Features phase and presses Enter, the code at line 382-409 builds `feature_prompts` from enabled features' secrets and appends them to `app.secret_prompts`. It then sets `app.phase = Phase::Secrets` to re-enter the Secrets phase. The `current_secret_index` is NOT reset — it should still point past the original base secrets, so the new feature prompts are the next ones shown. The `collecting_feature_secrets` flag ensures auto-advance goes to Confirm (not Features) when done.

**Potential bug:** If the user goes Confirm → Cancel → back to Secrets → through Secrets again → Features → Enter, the feature prompts get appended a SECOND time (duplicates). Also, `current_secret_index` was reset to 0 by `back_to_secrets()`, so all base secrets are re-prompted too.

**Step 1: Fix the duplicate feature prompts bug**

In `main.rs`, in `handle_features_key` Enter handler (around line 382), clear any previously-appended feature prompts before appending new ones. Also set `current_secret_index` to skip past base secrets.

Find the Enter handler in `handle_features_key` and replace:

```rust
KeyCode::Enter => {
    // Generate auth token before confirm
    app.config.auth_token = generate_auth_token();

    // Collect secrets for enabled features
    let mut feature_prompts = Vec::new();
    for feature in &app.config.features {
        if feature.enabled {
            for (key, _) in &feature.secrets {
                feature_prompts.push(SecretPrompt {
                    key: key.clone(),
                    description: format!("{} — {}", feature.name, key),
                    required: false,
                    is_secret: key.contains("TOKEN") || key.contains("KEY"),
                    value: None,
                });
            }
        }
    }

    if feature_prompts.is_empty() {
        app.advance(); // straight to Confirm
    } else {
        // Append feature secret prompts and go back to Secrets phase
        app.secret_prompts.extend(feature_prompts);
        app.collecting_feature_secrets = true;
        app.phase = Phase::Secrets;
    }
}
```

With:

```rust
KeyCode::Enter => {
    // Generate auth token before confirm
    app.config.auth_token = generate_auth_token();

    // Count base (non-feature) secret prompts
    let base_count = app.secret_prompts.iter()
        .take_while(|p| {
            // Base prompts come from manifest.required_secrets
            // Feature prompts have descriptions like "FeatureName — KEY"
            !p.description.contains(" — ")
        })
        .count();

    // Remove any previously appended feature prompts (handles Cancel → retry)
    app.secret_prompts.truncate(base_count);

    // Collect secrets for enabled features
    let mut feature_prompts = Vec::new();
    for feature in &app.config.features {
        if feature.enabled {
            for (key, _) in &feature.secrets {
                feature_prompts.push(SecretPrompt {
                    key: key.clone(),
                    description: format!("{} — {}", feature.name, key),
                    required: false,
                    is_secret: key.contains("TOKEN") || key.contains("KEY"),
                    value: None,
                });
            }
        }
    }

    if feature_prompts.is_empty() {
        app.advance(); // straight to Confirm
    } else {
        // Append feature secret prompts and go back to Secrets phase
        app.secret_prompts.extend(feature_prompts);
        app.current_secret_index = base_count; // skip past base secrets
        app.collecting_feature_secrets = true;
        app.phase = Phase::Secrets;
    }
}
```

**Step 2: Run cargo check**

Run: `cd tools/installer && cargo check`
Expected: Compiles with no errors

**Step 3: Run tests**

Run: `cd tools/installer && cargo test`
Expected: All 19 tests pass

**Step 4: Commit**

```bash
git add tools/installer/src/main.rs
git commit -m "fix(installer): prevent duplicate feature secret prompts on Cancel/retry (BAK-21)"
```

---

### Task 2: BAK-22 — Auto-Enable Feature Flags on Brain Deployment

**Files:**
- Modify: `tools/installer/src/templates/brain.yaml:87-88` (add FEATURE_VARS placeholder)
- Modify: `tools/installer/src/main.rs:920-941` (build_template_vars — add feature flag vars)
- Modify: `tools/installer/src/templates.rs` (update render function if needed)
- Test: `tools/installer/src/main.rs` (existing cargo tests)

**Context:** The brain's feature flag system (`packages/shared/src/features.ts`) reads `FEATURE_<SCREAMING_SNAKE>` env vars. Currently brain.yaml has only `FEATURE_EXTENSIONS: "true"` hardcoded. The installer needs to set feature flags based on what the user enabled.

**Step 1: Replace hardcoded FEATURE_EXTENSIONS with dynamic placeholder in brain.yaml**

In `tools/installer/src/templates/brain.yaml`, replace lines 87-88:

```yaml
            - name: FEATURE_EXTENSIONS
              value: "true"
```

With:

```yaml
{{FEATURE_VARS}}
```

**Step 2: Build feature env var block in build_template_vars**

In `tools/installer/src/main.rs`, in the `build_template_vars` function (line 920), after the image vars loop, add feature flag generation:

```rust
fn build_template_vars(namespace: &str, manifest: &ReleaseManifest, config: &app::InstallConfig) -> HashMap<String, String> {
    let mut vars = HashMap::new();
    vars.insert("NAMESPACE".into(), namespace.into());
    vars.insert("VERSION".into(), manifest.version.clone());
    vars.insert("AGENT_NAME".into(), config.agent_name.clone());
    vars.insert("DOOR_POLICY".into(), "open".into());
    for img in &manifest.images {
        let key = match img.component.as_str() {
            "brain" => "IMAGE_BRAIN",
            "worker" => "IMAGE_WORKER",
            "ui" => "IMAGE_UI",
            "gateway" => "IMAGE_GATEWAY",
            "voice" => "IMAGE_VOICE",
            "sysadmin" => "IMAGE_SYSADMIN",
            "ext-toolbox" => "IMAGE_TOOLBOX",
            "ext-browser" => "IMAGE_BROWSER",
            _ => continue,
        };
        vars.insert(key.into(), img.image.clone());
    }

    // Build FEATURE_VARS block from enabled features
    let mut feature_lines = Vec::new();
    let mut has_extension = false;
    for feature in &config.features {
        if feature.enabled {
            match feature.id.as_str() {
                "telegram" => feature_lines.push("            - name: FEATURE_TELEGRAM\n              value: \"true\"".to_string()),
                "discord" => feature_lines.push("            - name: FEATURE_DISCORD\n              value: \"true\"".to_string()),
                "voyage" => feature_lines.push("            - name: FEATURE_MEMORY\n              value: \"true\"".to_string()),
                "github" | "perplexity" | "browser" | "obsidian" => has_extension = true,
                _ => {}
            }
        }
    }
    if has_extension {
        feature_lines.push("            - name: FEATURE_EXTENSIONS\n              value: \"true\"".to_string());
    }
    // Always enable scheduler and MCP in prod
    feature_lines.push("            - name: FEATURE_SCHEDULER\n              value: \"true\"".to_string());
    feature_lines.push("            - name: FEATURE_MCP\n              value: \"true\"".to_string());

    vars.insert("FEATURE_VARS".into(), feature_lines.join("\n"));

    vars
}
```

**Step 3: Also update the non-interactive build_template_vars if it exists**

Check if there's a second `build_template_vars` for non-interactive mode (there was a duplicate around line 1155). Apply the same feature flag logic. Use the same pattern but read from the non-interactive config.

**Step 4: Run cargo check**

Run: `cd tools/installer && cargo check`
Expected: Compiles with no errors

**Step 5: Run tests**

Run: `cd tools/installer && cargo test`
Expected: All tests pass

**Step 6: Commit**

```bash
git add tools/installer/src/main.rs tools/installer/src/templates/brain.yaml
git commit -m "feat(installer): auto-enable FEATURE_* env vars based on selected features (BAK-22)"
```

---

### Task 3: BAK-23 — UI Conversation Persistence Across Navigation

**Files:**
- Modify: `services/ui/src/hooks/useChat.ts:78-81` (persist conversationId to sessionStorage)
- Modify: `services/ui/src/hooks/useChat.ts:104-107` (clear sessionStorage in newChat)
- Modify: `services/ui/src/pages/ChatPage.tsx:71-75` (restore from sessionStorage on mount)
- Test: `services/ui/src/hooks/__tests__/useChat.test.ts` (if exists, or skip — React hook testing requires vitest + testing-library setup)

**Context:** `useChat` is a plain React hook — state destroyed on unmount. Sidebar link goes to `/chat` (no ID), so navigating away drops the conversation. Fix: persist active conversation ID to `sessionStorage`, restore on mount.

**Step 1: Persist conversationId to sessionStorage when set**

In `services/ui/src/hooks/useChat.ts`, after line 80 (where `setConversationId(event.conversationId)` is called in the `done` handler), add sessionStorage persistence:

```typescript
} else if (event.type === 'done') {
  if (event.conversationId) {
    setConversationId(event.conversationId);
    sessionStorage.setItem('bakerst_active_conversation', event.conversationId);
  }
}
```

**Step 2: Clear sessionStorage in newChat**

In `services/ui/src/hooks/useChat.ts`, update `newChat` (line 104-107):

```typescript
const newChat = useCallback(() => {
  setMessages([]);
  setConversationId(undefined);
  sessionStorage.removeItem('bakerst_active_conversation');
}, []);
```

**Step 3: Restore conversation on ChatPage mount**

In `services/ui/src/pages/ChatPage.tsx`, modify the effect that loads conversations (around line 71-75). Add a new effect that checks sessionStorage when mounting without a URL param:

After the existing `useEffect` blocks (after line 81), add:

```typescript
// Restore last active conversation if navigating to /chat without an ID
useEffect(() => {
  if (!id && !conversationId && messages.length === 0) {
    const savedId = sessionStorage.getItem('bakerst_active_conversation');
    if (savedId) {
      loadConversation(savedId).catch(() => {
        // Conversation may have been deleted — clear stale reference
        sessionStorage.removeItem('bakerst_active_conversation');
      });
    }
  }
  // Only run on mount
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

**Step 4: Build the UI to verify**

Run: `cd services/ui && pnpm build`
Expected: Build succeeds with exit 0

**Step 5: Commit**

```bash
git add services/ui/src/hooks/useChat.ts services/ui/src/pages/ChatPage.tsx
git commit -m "fix(ui): persist active conversation across navigation (BAK-23)"
```

---

### Task 4: BAK-26 — SysAdmin Console Auth + Feature Flag Tools

This task has two parts: auth middleware and feature flag tools.

**Files:**
- Create: `services/sysadmin/src/tools/feature-flags.ts`
- Modify: `services/sysadmin/src/tools/index.ts` (add createFeatureFlagTools)
- Modify: `services/sysadmin/src/tool-registry.ts` (add tool names to state sets)
- Modify: `services/sysadmin/src/api.ts` (add auth middleware)
- Test: `services/sysadmin/src/__tests__/feature-flags.test.ts` (new)

#### Part A: Auth Middleware

**Step 1: Add bearer token auth to sysadmin API**

In `services/sysadmin/src/api.ts`, add auth middleware. The sysadmin already mounts `bakerst-brain-secrets` via `envFrom`, so `AUTH_TOKEN` is available as an env var.

Add after the imports (around line 10):

```typescript
import { timingSafeEqual } from 'node:crypto';

const AUTH_TOKEN = process.env.AUTH_TOKEN;

function checkAuth(req: Request, res: Response, next: () => void): void {
  if (!AUTH_TOKEN) {
    // Dev mode — no token set, allow all
    next();
    return;
  }
  const header = req.headers.authorization;
  if (!header?.startsWith('Bearer ')) {
    res.status(401).json({ error: 'Authorization required' });
    return;
  }
  const token = header.slice(7);
  try {
    const a = Buffer.from(token);
    const b = Buffer.from(AUTH_TOKEN);
    if (a.length === b.length && timingSafeEqual(a, b)) {
      next();
      return;
    }
  } catch {
    // length mismatch throws
  }
  res.status(403).json({ error: 'Invalid token' });
}
```

Apply the middleware to all routes except `/ping`. In the `createApi` function, before existing route definitions:

```typescript
app.use((req, res, next) => {
  if (req.path === '/ping') return next();
  checkAuth(req, res, next);
});
```

For WebSocket auth, in the `wss.on('connection')` handler, check the token from the URL query param `?token=`:

```typescript
wss.on('connection', (ws, req) => {
  if (AUTH_TOKEN) {
    const url = new URL(req.url ?? '', 'http://localhost');
    const token = url.searchParams.get('token');
    if (!token || !timingSafeEqual(Buffer.from(token), Buffer.from(AUTH_TOKEN))) {
      ws.close(4001, 'Unauthorized');
      return;
    }
  }
  // ... existing connection handler
});
```

Update the embedded terminal HTML to include a login prompt. In the HTML string served at `GET /`, add a password input that's shown before the terminal. The password is sent as `?token=` query param when opening the WebSocket.

**Step 2: Build and verify**

Run: `cd services/sysadmin && pnpm build`
Expected: Build succeeds

**Step 3: Commit auth changes**

```bash
git add services/sysadmin/src/api.ts
git commit -m "feat(sysadmin): add AUTH_TOKEN bearer auth to API and WebSocket (BAK-26)"
```

#### Part B: Feature Flag Tools

**Step 4: Write failing test for get_feature_flags**

Create `services/sysadmin/src/__tests__/feature-flags.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createFeatureFlagTools } from '../tools/feature-flags.js';

// Mock @kubernetes/client-node
vi.mock('@kubernetes/client-node', () => {
  const mockAppsApi = {
    readNamespacedDeployment: vi.fn(),
    patchNamespacedDeployment: vi.fn(),
  };
  return {
    KubeConfig: vi.fn().mockImplementation(() => ({
      loadFromDefault: vi.fn(),
      makeApiClient: vi.fn().mockReturnValue(mockAppsApi),
    })),
    AppsV1Api: vi.fn(),
  };
});

describe('feature-flags tools', () => {
  it('creates two tools', () => {
    const tools = createFeatureFlagTools();
    expect(tools).toHaveLength(2);
    expect(tools[0].definition.name).toBe('get_feature_flags');
    expect(tools[1].definition.name).toBe('set_feature_flag');
  });

  it('get_feature_flags returns flag status', async () => {
    const tools = createFeatureFlagTools();
    const getTool = tools[0];
    // Mock the K8s API to return a deployment with some FEATURE_ env vars
    const { KubeConfig } = await import('@kubernetes/client-node');
    const kc = new KubeConfig();
    const mockApi = kc.makeApiClient({} as any);
    (mockApi.readNamespacedDeployment as any).mockResolvedValue({
      spec: {
        template: {
          spec: {
            containers: [{
              env: [
                { name: 'FEATURE_TELEGRAM', value: 'true' },
                { name: 'FEATURE_EXTENSIONS', value: 'true' },
                { name: 'PORT', value: '3000' },
              ]
            }]
          }
        }
      }
    });
    const result = await getTool.handler({ deployment: 'brain' });
    expect(result).toContain('telegram');
    expect(result).toContain('true');
  });

  it('set_feature_flag patches deployment', async () => {
    const tools = createFeatureFlagTools();
    const setTool = tools[1];
    const { KubeConfig } = await import('@kubernetes/client-node');
    const kc = new KubeConfig();
    const mockApi = kc.makeApiClient({} as any);
    (mockApi.readNamespacedDeployment as any).mockResolvedValue({
      spec: {
        template: {
          spec: {
            containers: [{
              env: [
                { name: 'PORT', value: '3000' },
              ]
            }]
          }
        }
      }
    });
    (mockApi.patchNamespacedDeployment as any).mockResolvedValue({});
    const result = await setTool.handler({ flag: 'telegram', enabled: true });
    expect(result).toContain('telegram');
    expect(mockApi.patchNamespacedDeployment).toHaveBeenCalled();
  });
});
```

**Step 5: Run test to verify it fails**

Run: `cd services/sysadmin && pnpm test -- --run feature-flags`
Expected: FAIL — module not found

**Step 6: Implement feature-flags.ts**

Create `services/sysadmin/src/tools/feature-flags.ts`:

```typescript
import { KubeConfig, AppsV1Api } from '@kubernetes/client-node';
import type { RegisteredTool } from '../types.js';

const NAMESPACE = process.env.NAMESPACE ?? 'bakerst';

/** Known feature flags from packages/shared/src/features.ts */
const KNOWN_FLAGS: Record<string, string> = {
  telegram: 'FEATURE_TELEGRAM',
  discord: 'FEATURE_DISCORD',
  mcp: 'FEATURE_MCP',
  scheduler: 'FEATURE_SCHEDULER',
  observer: 'FEATURE_OBSERVER',
  reflector: 'FEATURE_REFLECTOR',
  memory: 'FEATURE_MEMORY',
  transferProtocol: 'FEATURE_TRANSFER_PROTOCOL',
  telemetry: 'FEATURE_TELEMETRY',
  taskPods: 'FEATURE_TASK_PODS',
  companions: 'FEATURE_COMPANIONS',
  extensions: 'FEATURE_EXTENSIONS',
};

/** Reverse map: FEATURE_TELEGRAM → telegram */
const ENV_TO_FLAG: Record<string, string> = {};
for (const [flag, env] of Object.entries(KNOWN_FLAGS)) {
  ENV_TO_FLAG[env] = flag;
}

/** Flags that require secrets to be useful */
const FLAG_SECRETS: Record<string, string[]> = {
  telegram: ['TELEGRAM_BOT_TOKEN'],
  discord: ['DISCORD_BOT_TOKEN'],
  memory: ['VOYAGE_API_KEY'],
};

function getAppsApi(): AppsV1Api {
  const kc = new KubeConfig();
  kc.loadFromDefault();
  return kc.makeApiClient(AppsV1Api);
}

export function createFeatureFlagTools(): RegisteredTool[] {
  return [
    {
      definition: {
        name: 'get_feature_flags',
        description: 'Get the current feature flag state from the brain deployment. Shows which FEATURE_* env vars are set and their values, plus known flags that are using mode defaults.',
        input_schema: {
          type: 'object' as const,
          properties: {
            deployment: {
              type: 'string',
              description: 'Deployment name to read flags from (default: brain)',
            },
          },
          required: [],
        },
      },
      handler: async (input: Record<string, unknown>) => {
        const name = (input.deployment as string) || 'brain';
        const api = getAppsApi();
        const dep = await api.readNamespacedDeployment({ name, namespace: NAMESPACE });
        const envVars = dep.spec?.template?.spec?.containers?.[0]?.env ?? [];

        const flags: Record<string, { value: string; source: string }> = {};

        // Collect FEATURE_* env vars from deployment
        for (const env of envVars) {
          if (env.name?.startsWith('FEATURE_') && ENV_TO_FLAG[env.name]) {
            flags[ENV_TO_FLAG[env.name]] = {
              value: env.value ?? 'unset',
              source: 'env override',
            };
          }
        }

        // Check BAKERST_MODE
        const modeVar = envVars.find((e) => e.name === 'BAKERST_MODE');
        const mode = modeVar?.value ?? 'prod';

        // Fill in known flags not explicitly set
        const MODE_DEFAULTS: Record<string, Record<string, boolean>> = {
          prod: { telegram: true, discord: true, mcp: true, scheduler: true, observer: true, reflector: true, memory: true, transferProtocol: true, telemetry: true, taskPods: false, companions: false, extensions: false },
          dev: { telegram: false, discord: false, mcp: false, scheduler: false, observer: true, reflector: true, memory: true, transferProtocol: false, telemetry: false, taskPods: false, companions: false, extensions: false },
        };
        const defaults = MODE_DEFAULTS[mode] ?? MODE_DEFAULTS.prod;
        for (const [flag, defaultVal] of Object.entries(defaults)) {
          if (!flags[flag]) {
            flags[flag] = { value: String(defaultVal), source: `${mode} default` };
          }
        }

        // Format output
        const lines = [`Feature flags for ${name} (mode: ${mode}):\n`];
        for (const [flag, info] of Object.entries(flags).sort(([a], [b]) => a.localeCompare(b))) {
          const icon = info.value === 'true' ? '✓' : '✗';
          lines.push(`  ${icon} ${flag}: ${info.value} (${info.source})`);
        }
        return lines.join('\n');
      },
    },
    {
      definition: {
        name: 'set_feature_flag',
        description: 'Enable or disable a feature flag on the brain deployment. Sets the FEATURE_* env var and triggers a rollout restart. If the feature requires secrets, you should check if they exist first and use ask_user to collect them if needed.',
        input_schema: {
          type: 'object' as const,
          properties: {
            flag: {
              type: 'string',
              description: 'Feature flag name (e.g., telegram, extensions, scheduler, memory)',
              enum: Object.keys(KNOWN_FLAGS),
            },
            enabled: {
              type: 'boolean',
              description: 'Whether to enable (true) or disable (false) the feature',
            },
          },
          required: ['flag', 'enabled'],
        },
      },
      handler: async (input: Record<string, unknown>) => {
        const flag = input.flag as string;
        const enabled = input.enabled as boolean;

        if (!KNOWN_FLAGS[flag]) {
          return `Unknown feature flag: ${flag}. Known flags: ${Object.keys(KNOWN_FLAGS).join(', ')}`;
        }

        const envName = KNOWN_FLAGS[flag];
        const api = getAppsApi();
        const name = 'brain';

        // Read current deployment
        const dep = await api.readNamespacedDeployment({ name, namespace: NAMESPACE });
        const containers = dep.spec?.template?.spec?.containers;
        if (!containers?.length) {
          return 'Error: brain deployment has no containers';
        }

        const env = containers[0].env ?? [];

        // Update or add the env var
        const existing = env.findIndex((e) => e.name === envName);
        if (existing >= 0) {
          env[existing] = { name: envName, value: String(enabled) };
        } else {
          env.push({ name: envName, value: String(enabled) });
        }
        containers[0].env = env;

        // Patch deployment
        await api.patchNamespacedDeployment({
          name,
          namespace: NAMESPACE,
          body: {
            spec: {
              template: {
                spec: { containers },
              },
            },
          },
        }, undefined, undefined, undefined, undefined, undefined, { headers: { 'Content-Type': 'application/strategic-merge-patch+json' } });

        const requiredSecrets = FLAG_SECRETS[flag];
        let secretNote = '';
        if (enabled && requiredSecrets?.length) {
          secretNote = `\n\nNote: ${flag} requires secrets: ${requiredSecrets.join(', ')}. Use ask_user to collect them if not already configured, then create_secret to store them.`;
        }

        return `Feature flag '${flag}' set to ${enabled} on ${name} deployment. Rollout restart triggered.${secretNote}`;
      },
    },
  ];
}
```

**Step 7: Register tools in index.ts**

In `services/sysadmin/src/tools/index.ts`, add:

```typescript
import { createFeatureFlagTools } from './feature-flags.js';
```

And in `createAllTools()`:

```typescript
export function createAllTools(): RegisteredTool[] {
  return [
    ...createK8sCoreTools(),
    ...createK8sDeployTools(),
    ...createK8sHealthTools(),
    ...createVerifyIntegrityTools(),
    ...createReleaseManifestTools(),
    ...createAskUserTools(),
    ...createTransitionTools(),
    ...createFeatureFlagTools(),
  ];
}
```

**Step 8: Add tools to state registry**

In `services/sysadmin/src/tool-registry.ts`, add `'get_feature_flags'` to the `verify`, `runtime`, and `update` sets. Add `'set_feature_flag'` to the `runtime` and `update` sets:

```
verify: add 'get_feature_flags'
runtime: add 'get_feature_flags', 'set_feature_flag'
update: add 'get_feature_flags', 'set_feature_flag'
```

**Step 9: Run tests**

Run: `cd services/sysadmin && pnpm test -- --run`
Expected: All tests pass including new feature-flags tests

**Step 10: Build**

Run: `cd services/sysadmin && pnpm build`
Expected: Build succeeds

**Step 11: Commit**

```bash
git add services/sysadmin/src/tools/feature-flags.ts services/sysadmin/src/tools/index.ts services/sysadmin/src/tool-registry.ts services/sysadmin/src/api.ts services/sysadmin/src/__tests__/feature-flags.test.ts
git commit -m "feat(sysadmin): add auth + feature flag query/toggle tools (BAK-26)"
```

---

### Verification

After all 4 tasks:

1. `cd tools/installer && cargo test` — all Rust tests pass
2. `cd services/ui && pnpm build` — UI builds
3. `cd services/sysadmin && pnpm test -- --run` — sysadmin tests pass
4. `cd services/sysadmin && pnpm build` — sysadmin builds

### Summary

| Task | Issue | Area | What Changes |
|------|-------|------|-------------|
| 1 | BAK-21 | Installer (Rust) | Fix duplicate feature prompts, ensure secrets collected |
| 2 | BAK-22 | Installer (Rust) + brain.yaml | Add FEATURE_VARS to brain template, populate from enabled features |
| 3 | BAK-23 | UI (React) | sessionStorage for active conversation ID, restore on mount |
| 4 | BAK-26 | SysAdmin (Node.js) | Bearer auth on API/WS, get_feature_flags + set_feature_flag tools |
